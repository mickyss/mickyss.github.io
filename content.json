[{"title":"sql合并列","date":"2017-03-17T14:25:03.000Z","path":"2017/03/17/sql合并列/","text":"sql合并列的基本使用情况是因为有些业务需要根据表字段的值而选择left join哪张表select isnull(a.name,&#39;&#39;)+isnull(u.name,&#39;&#39;) as name from a LEFT JOIN user u on u.user_id = a.user_id and a.center_user = 0 LEFT JOIN quser qu on qu.user_id = a.user_id and a.center_user = 1 因为需要判断值是否为null，值为null的列做任何运算都会等于null 附：ISNULL语法 使用指定的替换值替换 NULL。 语法ISNULL ( check_expression , replacement_value ) 参数check_expression 将被检查是否为 NULL的表达式。check_expression 可以是任何类型的。 replacement_value 在 check_expression 为 NULL时将返回的表达式。replacement_value 必须与 check_expresssion 具有相同的类型。 http://database.51cto.com/art/201009/224323.htm","tags":[{"name":"sql","slug":"sql","permalink":"http://yitiaoxinqing.com/tags/sql/"}]},{"title":"在sourcetree双击了某个commit","date":"2017-03-16T14:06:26.000Z","path":"2017/03/16/在sourcetree双击了某个commit/","text":"ok,动作如标题（用extension也是一样） 首先你的git仓库会在这里切换到了一个分离（游离）的分支，一个被head分支也指向的分支。 ps:head是一个当前分支的指向，也就是凌驾于所有分支的上层，当前仓库在哪个分支下就指向哪里。 每个分支会有一串sha1值标识，如果你现在想提交到远程你双击以后的修改（做了一些更改，想重新合到master），先提交到当前仓库，然后切回master分支或其他分支， （这里敲重点） 你会发现之前做的分支没有了，代码也没有了. 在左侧也没有分支（如果你只有一个master，那就只剩下一个master） 使用git reflog可以查看所有分支操作记录 这里你会看到一个没有分支名的切换分支动作， checkout: moving from 42d4fg2(一串sha1值) 正常的操作应该是 checkout: moving from msater to 另一个分支名 所以这里的42d4fg2(一串sha1值)就是你双击了某个commit切出来的一个游离分支，你提交的代码都在里面，现在你只要在master里合并这个分支就行了 git是支持简写的，sha1只需要打前5位基本就可以啦，所以在master分支里敲下 git merge 42d4fg2(一串sha1值)** 注：在这里敲下git reflog 查看的历史记录，记得分清git flow产生的sha1值，假设双击后产生sha1 A 值，那提交代码后会产生sha1 B值，所以这里合并代码要敲进去的是sha1 A值。","tags":[{"name":"git","slug":"git","permalink":"http://yitiaoxinqing.com/tags/git/"},{"name":"sourcetree","slug":"sourcetree","permalink":"http://yitiaoxinqing.com/tags/sourcetree/"}]},{"title":"Hello World","date":"2017-03-14T13:36:54.646Z","path":"2017/03/14/hello-world/","text":"Hello World! 折腾了好久终于算是搞定了吧，接下来会把印象笔记，csdn上的一些博客都逐渐的转移到github page这里啦，感谢github~感谢hexo~","tags":[]}]