[{"title":"在oracle数据库创建定时任务","date":"2017-09-17T14:06:26.000Z","path":"2017/09/17/在oracle数据库创建定时任务/","text":"* 查询job * select job,broken,what,interval,t.* from user_jobs t; * job创建语句 create or replace procedure procautoexecjobas begin declare job number;BEGIN DBMSJOB.SUBMIT( JOB =&gt; job, /自动生成JOBID/ W HAT =&gt; ‘psspworkloadpushdata;’, /需要执行的过程或SQL语句/ NEXTDATE =&gt; TRUNC(SYSDATE+1)+(060+30)/(2460), /初次执行时间，12点30分/ INTERVAL =&gt; ‘TRUNC(SYSDATE+1)+(060+30)/(2360)’ /每天12点30分/ );COMMIT; DBMS_JOB.RUN(job);end; end procautoexec_job; * 删除Job 在Pl/sql dbms_jobs 文件夹下直接删除 * 首先确定要停止的JOB号 在10g中可通过DbaJobsRunning进行确认。 查找正在运行的JOB: select sid from dbajobsrunning; * 定时语法 * todate( concat( tochar( sysdate+1,&apos;dd-mm-yyyy&apos;),&apos; 23:00:00&apos;),&apos;dd-mm-yyyy hh24:mi:ss&apos;) 注：dbms_jobs 是在plsql文件夹下的， navicat是看不到Job的。创建job，然后执行是通过存储过程去触发的。","tags":[{"name":"oracle","slug":"oracle","permalink":"http://yitiaoxinqing.com/tags/oracle/"}]},{"title":"git提交前需要先合并commit","date":"2017-04-11T14:26:17.000Z","path":"2017/04/11/git提交前需要先合并commit/","text":"为了便于他人阅读你的提交，也便于cherry-pick或撤销代码变化，在发起Pull Request之前，应该把多个commit合并成一个。（前提是，该分支只有你一个人开发，且没有跟master合并过。）","tags":[]},{"title":"sql合并列","date":"2017-03-17T14:25:03.000Z","path":"2017/03/17/sql合并列/","text":"sql合并列的基本使用情况是因为有些业务需要根据表字段的值而选择left join哪张表select isnull(a.name,&#39;&#39;)+isnull(u.name,&#39;&#39;) as name from a LEFT JOIN user u on u.user_id = a.user_id and a.center_user = 0 LEFT JOIN quser qu on qu.user_id = a.user_id and a.center_user = 1 因为需要判断值是否为null，值为null的列做任何运算都会等于null 附：ISNULL语法 使用指定的替换值替换 NULL。 语法ISNULL ( check_expression , replacement_value ) 参数check_expression 将被检查是否为 NULL的表达式。check_expression 可以是任何类型的。 replacement_value 在 check_expression 为 NULL时将返回的表达式。replacement_value 必须与 check_expresssion 具有相同的类型。 http://database.51cto.com/art/201009/224323.htm","tags":[{"name":"sql","slug":"sql","permalink":"http://yitiaoxinqing.com/tags/sql/"}]},{"title":"在sourcetree双击了某个commit","date":"2017-03-16T14:06:26.000Z","path":"2017/03/16/在sourcetree双击了某个commit/","text":"ok,动作如标题（用extension也是一样） 首先你的git仓库会在这里切换到了一个分离（游离）的分支，一个被head分支也指向的分支。 ps:head是一个当前分支的指向，也就是凌驾于所有分支的上层，当前仓库在哪个分支下就指向哪里。 每个分支会有一串sha1值标识，如果你现在想提交到远程你双击以后的修改（做了一些更改，想重新合到master），先提交到当前仓库，然后切回master分支或其他分支， （这里敲重点） 你会发现之前做的分支没有了，代码也没有了. 在左侧也没有分支（如果你只有一个master，那就只剩下一个master） 使用git reflog可以查看所有分支操作记录 这里你会看到一个没有分支名的切换分支动作， checkout: moving from 42d4fg2(一串sha1值) 正常的操作应该是 checkout: moving from msater to 另一个分支名 所以这里的42d4fg2(一串sha1值)就是你双击了某个commit切出来的一个游离分支，你提交的代码都在里面，现在你只要在master里合并这个分支就行了 git是支持简写的，sha1只需要打前5位基本就可以啦，所以在master分支里敲下 git merge 42d4fg2(一串sha1值)** 注：在这里敲下git reflog 查看的历史记录，记得分清git flow产生的sha1值，假设双击后产生sha1 A 值，那提交代码后会产生sha1 B值，所以这里合并代码要敲进去的是sha1 A值。","tags":[{"name":"git","slug":"git","permalink":"http://yitiaoxinqing.com/tags/git/"},{"name":"sourcetree","slug":"sourcetree","permalink":"http://yitiaoxinqing.com/tags/sourcetree/"}]},{"title":"Hello World","date":"2017-03-14T13:36:54.646Z","path":"2017/03/14/hello-world/","text":"Hello World! 折腾了好久终于算是搞定了吧，接下来会把印象笔记，csdn上的一些博客都逐渐的转移到github page这里啦，感谢github~感谢hexo~","tags":[]}]